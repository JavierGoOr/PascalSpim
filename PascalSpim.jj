/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. .\PascalSpim.jj */
/*@egen*/// Pascal to SPIM parser. File for JavaCC
options
{
  IGNORE_CASE = true;                 
}

PARSER_BEGIN(PascalSpim)

import java.util.Vector;

public class PascalSpim/*@bgen(jjtree)*/implements PascalSpimTreeConstants/*@egen*/
{/*@bgen(jjtree)*/
  protected static JJTPascalSpimState jjtree = new JJTPascalSpimState();

/*@egen*/
	public static void main(String args[])
	{
		PascalSpim ps = new PascalSpim(System.in);
		try
		{
			SimpleNode n = ps.programStart();
			//n.dump("");
			System.out.println("Thank you.");
			SymbolTable st = SymbolTable.getInstance();
			/*Constant entry = (Constant) ((SymbolTableEntry) st.getSymbol("h1", "")).getObject();
			System.out.println(entry);
			entry = (Constant) ((SymbolTableEntry) st.getSymbol("h2", "")).getObject();
			System.out.println(entry);
			entry = (Constant) ((SymbolTableEntry) st.getSymbol("h3", "")).getObject();
			System.out.println(entry);
			entry = (Constant) ((SymbolTableEntry) st.getSymbol("h4", "")).getObject();
			System.out.println(entry);
			entry = (Constant) ((SymbolTableEntry) st.getSymbol("adios", "")).getObject();
			System.out.println(entry);
			StringType entry2 = (StringType) ((SymbolTableEntry) st.getSymbol("t1", "")).getObject();
			System.out.println(entry2.getResLength());
			entry2 = (StringType) ((SymbolTableEntry) st.getSymbol("t2", "")).getObject();
			System.out.println(entry2.getResLength());
			Variable entry3 = (Variable) ((SymbolTableEntry) st.getSymbol("v3", "")).getObject();
			System.out.println(((StringType)entry3.getType()).getResLength());*/
			System.out.println( ((SymbolTableEntry) st.getSymbol("h1", "1")).getScope() );
			System.out.println( ((SymbolTableEntry) st.getSymbol("hola", "1")).getScope() );
			System.out.println( ((SymbolTableEntry) st.getSymbol("adios", "1")).getScope() );
			System.out.println( ((SymbolTableEntry) st.getSymbol("v1", "1")).getScope() );
			System.out.println(st.getSymbol("f1", "1-1-1"));
			System.out.println(st.getSymbol("f11", "1-1-1"));
		}
		catch (ParseException e)
		{
			System.out.println("Oops.");
			System.out.println(e.getMessage());
			e.printStackTrace();
		}
	}
	public static void error_skipto(int kind, ParseException e)
	{
		System.out.println(e.toString());
		Token t;
		do
		{
			t = getNextToken();
		}while (t.kind != kind);
	}
}

PARSER_END(PascalSpim)

SKIP: //Whitespace and comments
{
    " "
  | "\t"
  | "\n"
  | "\r"
  | "(*" : INSIDE_COMMENT_1
  | "{" : INSIDE_COMMENT_2
}

<INSIDE_COMMENT_1>
SKIP:
{
    "*)" : DEFAULT
  | <~[]>
}

<INSIDE_COMMENT_2>
SKIP:
{
    "}" : DEFAULT
  | <~[]>
}

TOKEN: //Keywords
{
    < PROGRAM : "program" >
  | < BEGIN : "begin" >
  | < END : "end" >
  | < IF : "if" >
  | < THEN : "then" >
  | < ELSE : "else" >
  | < WHILE : "while" >
  | < CASE : "case" >
  | < OF : "of" >
  | < DO : "do" >
  | < UNTIL : "until" >
  | < FUNCTION : "function" >
  | < PROCEDURE : "procedure" >
  | < VAR : "var" >
  | < CONST : "const" >
  | < TYPE : "type" >
  | < TRUE : "true" >
  | < FALSE : "false" >
}

TOKEN: //Special characters
{
    < EOS : ";" > /* End of sentence */
  | < COMMA : "," >
  | < COLON : ":" >
  | < DDOT : ".." >
  | < DOT : "." >
  | < OP_BRAC : "[" >
  | < CL_BRAC : "]" >
  | < OP_PAR : "(" >
  | < CL_PAR : ")" >
}

TOKEN: //Operators
{
    < PLUS : "+" >
  | < MINUS : "-" >
  | < MULT : "*" >
  | < DIV : "div" >
  | < MOD : "mod" >
  | < DIVR : "/" >
  | < AND : "and" >
  | < OR : "or" >
  | < NOT : "not" >
  | < ASSIGN : ":=" >
  | < LT : "<" >
  | < GT : ">" >
  | < EQ : "=" >
  | < LET : "<=" >
  | < GET : ">=" >
  | < NE : "<>" >
}

TOKEN: //Data types
{
    < INTEGER : "integer" >
  | < REAL : "real" >
  | < BOOLEAN : "boolean" >
  | < CHAR : "char" >
  | < STRING : "string" >
  | < ARRAY : "array" >
}

TOKEN: //Constants and identifiers
{
    < #LETTER : ["a"-"z", "_"] >
  | < #DIGIT : ["0"-"9"] >
  | < ID : <LETTER> (<LETTER>|<DIGIT>)* >
  | < UNS_INT : (<DIGIT>)+ > //Unsigned integer
  | < UNS_NUM : <UNS_INT> (<DOT> (<DIGIT>)+)? ("e" ( <PLUS> | <MINUS> )? <UNS_INT>)? > //Unsigned number
  | < STLIT : "'" (~["'"])* "'" > //String literal
}


SKIP:
{
	<~[]>	{System.out.println("Illegal character: " + image);}
}

//**********************************************
//*************START OF GRAMMAR*****************
//**********************************************

SimpleNode programStart() :
{/*@bgen(jjtree) programStart */
        ASTprogramStart jjtn000 = new ASTprogramStart(JJTPROGRAMSTART);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	String scope = "1";
	Token t;
}
{/*@bgen(jjtree) programStart */
        try {
/*@egen*/
	try{ <PROGRAM> } catch(ParseException e) { error_skipto(PROGRAM, e); }
	t = <ID> { jjtn000.setName(t.image); }
	<EOS>
	block(scope)
	<DOT>/*@bgen(jjtree)*/
        {
          jjtree.closeNodeScope(jjtn000, true);
          jjtc000 = false;
        }
/*@egen*/
	{ return jjtn000; }/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

Constant constant(String scope)       :
{
	Token t = null, sign = null;
	Constant c = null;
	SymbolTable st = SymbolTable.getInstance();
	SymbolTableEntry ste;
	boolean identifier = false;
}
{
	(
		( sign = <PLUS> | sign = <MINUS> )?
		(
			t = <ID>
			{	identifier = true;	
				ste = st.getSymbol(t.image, scope);
				if(ste == null)
					throw new ParseException(t.image + "no est\u00e1 definida");
				else if(ste.getObject() instanceof Constant)
					c = (Constant) ste.getObject();	}
		|
			t = <UNS_NUM>
			{ c = new RealConstant(); }
		|
			t = <UNS_INT>
			{ c = new IntegerConstant(); }
		)
	|
		t = <STLIT>
		{ c = new StringConstant(); }
	|
		( t = <TRUE> | t = <FALSE> )	
		{ c = new BooleanConstant(); }
	)
	{	if(!identifier)
		{	
			if(sign == null) 
				c.storePascalValue(t.image);
			else
				c.storePascalValue(sign.image + t.image);
		}
	  	return c; }
}

SymbolTableObject uns_constant(String scope)       :
{
	Token t = null, sign = null;
	Constant c = null;
	Variable v = null;
	SymbolTable st = SymbolTable.getInstance();
	SymbolTableEntry ste;
	boolean identifier = false, var = false;
}
{
	(
		t = <ID> //it can also be a variable, because of the grammar
		{
			identifier = true;	
			ste = st.getSymbol(t.image, scope);
			if(ste == null)
				throw new ParseException(t.image + "no est\u00e1 definida");
			else if(ste.getObject() instanceof Constant)
				c = (Constant) ste.getObject();
			else if(ste.getObject() instanceof Variable)
			{
				v = (Variable) ste.getObject();
				var = true;
			}
		}
	|
		t = <UNS_NUM>
		{ c = new RealConstant(); }
	|
		t = <UNS_INT>
		{ c = new IntegerConstant(); }
	|
		t = <STLIT>
		{ c = new StringConstant(); }
	|
		( t = <TRUE> | t = <FALSE> )	
		{ c = new BooleanConstant(); }
	)
	{
		if(!identifier)
		{	
			c.storePascalValue(sign.image + t.image);
		}
		if(var)
			return v;
		else
	  		return c;
	}
}

void constBlock(String scope)       :
{
	Token t;
	Constant c;
	SymbolTable st = SymbolTable.getInstance();
}
{
	<CONST>
	(
		t = <ID>
		<EQ>
		c = constant(scope)
		{	st.addSymbol(new SymbolTableEntry(t.image, scope, c)); }
		<EOS>
	)+
}

void typeBlock(String scope)       :
{
	Token t;
	Type tp;
	SymbolTable st = SymbolTable.getInstance();
}
{
	<TYPE>
	(
		t = <ID>
		<EQ>
		tp = typeConst(scope)
		{ st.addSymbol(new SymbolTableEntry(t.image, scope, tp)); }
		<EOS>
	)+
}

void varBlock(String scope)       :
{
	Vector v = new Vector();
	Variable var;
	Token t;
	Type tp;
	SymbolTable st = SymbolTable.getInstance();
}
{
	<VAR>
	(
		t = <ID> 			{v.add(t);}
		(
			<COMMA>
			t = <ID>			{v.add(t);}
		)*
		<COLON>
		tp = typeConst(scope)
		{
			for(int i = 0; i < v.size(); i++)
			{
				t = (Token) v.elementAt(i);
				var = new Variable(tp, false, false);
				st.addSymbol(new SymbolTableEntry(t.image, scope, var));
			}
			v = new Vector();
		}
		<EOS>
	)+
}

void functionBlock(String scope) :
{/*@bgen(jjtree) functionBlock */
        ASTfunctionBlock jjtn000 = new ASTfunctionBlock(JJTFUNCTIONBLOCK);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	Type tp;
}
{/*@bgen(jjtree) functionBlock */
        try {
/*@egen*/
	<FUNCTION> <ID> parameterList(jjtn000, scope)
	<COLON>
	tp = typeConst(scope)
	{jjtn000.setReturnType(tp);}
	<EOS>
	block(scope) <EOS>/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void procedureBlock(String scope):
{/*@bgen(jjtree) procedureBlock */
  ASTprocedureBlock jjtn000 = new ASTprocedureBlock(JJTPROCEDUREBLOCK);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) procedureBlock */
        try {
/*@egen*/
	<PROCEDURE> <ID> parameterList(jjtn000, scope) <EOS>
	block(scope) <EOS>/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void block(String scope) :
{/*@bgen(jjtree) block */
        ASTblock jjtn000 = new ASTblock(JJTBLOCK);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	int i = 0;
}
{/*@bgen(jjtree) block */
        try {
/*@egen*/
	( constBlock(scope)	)?
	( typeBlock(scope) )?
	( varBlock(scope) )?
	(
		functionBlock(scope + "-" + i) {i++;}
	|
		procedureBlock(scope + "-" + i) {i++;}
	)*
	<BEGIN>   //I have decided that each statement has to have an ; at its end
	(
		statement(scope)
		<EOS>
	)* 
	<END>/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

Type typeConst(String scope)       :
{
	Type tp = null, tp2;
	Token t = null, sign = null;
	int min = 0, max = 0, i = 0;
}
{
	(
		<INTEGER> { tp = new IntegerType(); }
	|
		<REAL> { tp = new RealType(); }
	|
		<BOOLEAN> { tp = new BooleanType(); }
	|
		<CHAR> { tp = new CharType(); }
	|
		<ID>//HACERRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRR
	|
		<STRING>
		( <OP_BRAC> t=<UNS_INT> <CL_BRAC>)?
		{	if(t != null) 
				tp = new StringType(Integer.parseInt(t.image));
			else
				tp = new StringType(); }
	|
		<ARRAY> <OP_BRAC>
		{tp = new ArrayType();}
		
		( sign = <PLUS>| sign = <MINUS>)? 
		t = <UNS_INT>
		
		{	if(sign != null) 
				min = Integer.parseInt(t.image);
			else
				min = Integer.parseInt(sign.image + t.image);
		}
		
		<DDOT>
		( sign = <PLUS>| sign = <MINUS>)? 
		t = <UNS_INT>
		{	if(sign != null) 
				max = Integer.parseInt(t.image);
			else
				max = Integer.parseInt(sign.image + t.image);
		}
		
		{
			((ArrayType) tp).setDimensions(i, min, max);
			i++;
		}
		
		(
			<COMMA>
			( sign = <PLUS>| sign = <MINUS>)? 
			t = <UNS_INT>
		
			{	if(sign != null) 
					min = Integer.parseInt(t.image);
				else
					min = Integer.parseInt(sign.image + t.image);
			}
		
			<DDOT>
			( sign = <PLUS>| sign = <MINUS>)? 
			t = <UNS_INT>
			{	if(sign != null) 
					max = Integer.parseInt(t.image);
				else
					max = Integer.parseInt(sign.image + t.image);
			}
		
			{
				((ArrayType) tp).setDimensions(i, min, max);
				i++;
			}
		)? 
		<CL_BRAC> <OF> 
		tp2 = typeConst(scope)
		{	((ArrayType) tp).setElsType(tp2);	}
	)
	{ return tp; }
}

void factor(String scope) :
{/*@bgen(jjtree) factor */
        ASTfactor jjtn000 = new ASTfactor(JJTFACTOR);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
/*@egen*/
	SymbolTableObject sto;
}
{/*@bgen(jjtree) factor */
        try {
/*@egen*/
	(
		LOOKAHEAD(2)
		sto = uns_constant(scope)
	|
		<ID> //function identifier or variable
		(
			(
				<OP_BRAC> //for variables
				expression(scope)
				(<COMMA> expression(scope) )*
				<CL_BRAC>
			)+
		|
			<OP_PAR> //for functions
			expression(scope)
			(<COMMA> expression(scope) )*
			<CL_PAR>
		)
	|
		<OP_PAR> expression(scope) <CL_PAR>
	|
		<NOT> factor(scope)
	)/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void term(String scope) :
{/*@bgen(jjtree) term */
  ASTterm jjtn000 = new ASTterm(JJTTERM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) term */
        try {
/*@egen*/
	factor(scope)
	(
		(<MULT>|<DIVR>|<DIV>|<MOD>|<AND>)
		factor(scope)
	)*/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void simpExpression(String scope) :
{/*@bgen(jjtree) simpExpression */
  ASTsimpExpression jjtn000 = new ASTsimpExpression(JJTSIMPEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) simpExpression */
        try {
/*@egen*/
	(<PLUS>|<MINUS>)?
	term(scope)
	(
		(<PLUS>|<MINUS>|<OR>)
		term(scope)
	)*/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void expression(String scope) :
{/*@bgen(jjtree) expression */
  ASTexpression jjtn000 = new ASTexpression(JJTEXPRESSION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) expression */
        try {
/*@egen*/
	simpExpression(scope)
	(
		(<EQ>|<LT>|<GT>|<NE>|<LET>|<GET>)
		simpExpression(scope)
	)*/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void parameterList(ParametersManagement funcNode, String scope)       :
{}
{
	(
		<OP_PAR>
		subParList(funcNode, scope)
		( <EOS> subParList(funcNode, scope) )*
		<CL_PAR>
	)?
}

void subParList(ParametersManagement funcNode, String scope)       :
{
	Token t;
	boolean isOutput = false;
	Variable var;
	Vector v = new Vector();
	Type tp;
	SymbolTable st = SymbolTable.getInstance();
	SymbolTableEntry ste;
}
{
	(<VAR> { isOutput = true; }  )?
	t = <ID>			{v.add(t);}
	(
		<COMMA>
		t = <ID>		{v.add(t);}
	)*
	<COLON>
	tp = typeConst(scope)
	{
		for(int i = 0; i < v.size(); i++)
		{
			t = (Token) v.elementAt(i);
			var = new Variable(tp, true, isOutput);
			ste = new SymbolTableEntry(t.image, scope, var);
			st.addSymbol(ste);
			funcNode.addParameter(ste);
		}
		v = new Vector();
	}
}
void statement(String scope) :
{/*@bgen(jjtree) statement */
  ASTstatement jjtn000 = new ASTstatement(JJTSTATEMENT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) statement */
        try {
/*@egen*/
	(
		<ID> //function identifier or variable
		(
			<OP_PAR> //procedure call
			expression(scope)
			( <COMMA> expression(scope) )*
			<CL_PAR>
		|
			(<OP_BRAC> expression(scope) (<COMMA> expression(scope))* <CL_BRAC>)* //for variables
			<ASSIGN> expression(scope)
		)?
	|
		<BEGIN>
		( statement(scope) <EOS> )*
		<END>
	|
		<IF> expression(scope) <THEN>
		statement(scope)
		(	LOOKAHEAD(2)
			<EOS>
			<ELSE>
			statement(scope)
		)?
	|
		<CASE> expression(scope) <OF>
		(
			caseSequence(scope)
			(caseSequence(scope) )*
			(
				<ELSE>
				statement(scope)
				<EOS>
			)?
		|
			<ELSE>
			statement(scope)
			<EOS>
		)
		<END>
	|
		<WHILE>
		expression(scope)
		<DO>
		statement(scope)
	)/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}

void caseSequence(String scope) :
{/*@bgen(jjtree) caseSequence */
  ASTcaseSequence jjtn000 = new ASTcaseSequence(JJTCASESEQUENCE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) caseSequence */
        try {
/*@egen*/
	constant(scope)
	(<COMMA> constant(scope))*
	<COLON>
	statement(scope)
	<EOS>/*@bgen(jjtree)*/
        } catch (Throwable jjte000) {
          if (jjtc000) {
            jjtree.clearNodeScope(jjtn000);
            jjtc000 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte000 instanceof RuntimeException) {
            throw (RuntimeException)jjte000;
          }
          if (jjte000 instanceof ParseException) {
            throw (ParseException)jjte000;
          }
          throw (Error)jjte000;
        } finally {
          if (jjtc000) {
            jjtree.closeNodeScope(jjtn000, true);
          }
        }
/*@egen*/
}
