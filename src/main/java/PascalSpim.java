/* Generated By:JavaCC: Do not edit this line. PascalSpim.java */

import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.util.Vector;

public class PascalSpim implements PascalSpimConstants {
    static final private int[] jj_la1 = new int[59];
    static final private JJCalls[] jj_2_rtns = new JJCalls[1];
    static final private LookaheadSuccess jj_ls = new LookaheadSuccess();
    static public PascalSpimTokenManager token_source;
    static public Token token, jj_nt;
    static public boolean lookingAhead = false;
    static SimpleCharStream jj_input_stream;
    static private boolean jj_initialized_once = false;
    static private int jj_ntk;
    static private Token jj_scanpos, jj_lastpos;
    static private int jj_la;
    static private boolean jj_semLA;
    static private int jj_gen;
    static private int[] jj_la1_0;
    static private int[] jj_la1_1;
    static private int[] jj_la1_2;
    static private boolean jj_rescan = false;
    static private int jj_gc = 0;
    static private java.util.Vector jj_expentries = new java.util.Vector();
    static private int[] jj_expentry;
    static private int jj_kind = -1;
    static private int[] jj_lasttokens = new int[100];
    static private int jj_endpos;

    static {
        jj_la1_0();
        jj_la1_1();
        jj_la1_2();
    }

    public PascalSpim(java.io.InputStream stream) {
        this(stream, null);
    }

    public PascalSpim(java.io.InputStream stream, String encoding) {
        if (jj_initialized_once) {
            System.out.println("ERROR: Second call to constructor of static parser.  You must");
            System.out.println("       either use ReInit() or set the JavaCC option STATIC to false");
            System.out.println("       during parser generation.");
            throw new Error();
        }
        jj_initialized_once = true;
        try {
            jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1);
        } catch (java.io.UnsupportedEncodingException e) {
            throw new RuntimeException(e);
        }
        token_source = new PascalSpimTokenManager(jj_input_stream);
        token = new Token();
        jj_ntk = -1;
        jj_gen = 0;
        for (int i = 0; i < 59; i++) jj_la1[i] = -1;
        for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
    }

    public PascalSpim(java.io.Reader stream) {
        if (jj_initialized_once) {
            System.out.println("ERROR: Second call to constructor of static parser.  You must");
            System.out.println("       either use ReInit() or set the JavaCC option STATIC to false");
            System.out.println("       during parser generation.");
            throw new Error();
        }
        jj_initialized_once = true;
        jj_input_stream = new SimpleCharStream(stream, 1, 1);
        token_source = new PascalSpimTokenManager(jj_input_stream);
        token = new Token();
        jj_ntk = -1;
        jj_gen = 0;
        for (int i = 0; i < 59; i++) jj_la1[i] = -1;
        for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
    }
    public PascalSpim(PascalSpimTokenManager tm) {
        if (jj_initialized_once) {
            System.out.println("ERROR: Second call to constructor of static parser.  You must");
            System.out.println("       either use ReInit() or set the JavaCC option STATIC to false");
            System.out.println("       during parser generation.");
            throw new Error();
        }
        jj_initialized_once = true;
        token_source = tm;
        token = new Token();
        jj_ntk = -1;
        jj_gen = 0;
        for (int i = 0; i < 59; i++) jj_la1[i] = -1;
        for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
    }

    public static void main(String args[]) throws Exception {
        String file_in = "", file_out = "";
        if (args.length != 2) {
            System.out.println("Error: incorrect number of parameters.");
            System.out.println("The way to execute this program is:");
            System.out.println("\"java PascalSpim <file_in> <file_out>\"");
            return;
        } else {
            file_in = args[0];
            file_out = args[1];
        }
        PascalSpim ps;
        try {
            ps = new PascalSpim(new BufferedReader(new FileReader(file_in)));
        } catch (IOException e) {
            System.out.println("Error: file \"" + file_in + "\" cannot be read. Please check whether it exists.");
            return;
        }
        Program n = programStart();
        SymbolTable st = SymbolTable.getInstance();
        if (st.getError()) {
            System.out.println("Process finished with errors");
        } else {
            System.out.println("Process finished correctly.");
            n.generateCode();
            Code code = Code.getInstance();
            boolean done = code.writeCode(file_out);
            if (!done) {
                System.out.println("Error: file \"" + file_out + "\" could not be written.");
            }
        }
    }

    public static void error_skipto(int kind, ParseException e) {
        System.out.println(e.toString());
        Token t;
        do {
            t = getNextToken();
        } while (t.kind != kind);
    }

    public static void error_skipto_before(int kind, ParseException e) {
        System.out.println(e.toString());
        while (getToken(1).kind != kind) {
            getNextToken();
        }
    }

    public static void printError(int line, int column, String text) {
        SymbolTable st = SymbolTable.getInstance();
        st.setError(true);
        System.out.println("Error at line " + line + ", column " + column + " : " + text);
        System.out.println();
    }

    public static void printParseExc(ParseException pe) {
        SymbolTable st = SymbolTable.getInstance();
        st.setError(true);
        System.out.println(pe.toString().substring(16));
    }

    //**********************************************
//*************START OF GRAMMAR*****************
//**********************************************
    static final public Program programStart() throws ParseException {
        String scope = "1";
        Block b;
        Token t = null;
        boolean error = false;
        try {
            jj_consume_token(PROGRAM);
        } catch (ParseException e) {
            boolean synch = false;
            printParseExc(e);
            error = true;
            while (!synch) {
                switch (getToken(1).kind) {
                    case EOF:
                        synch = true;
                        break;
                    case PROGRAM:
                        synch = true;
                        getNextToken();
                        break;
                    default:
                        getNextToken();
                }
            }
        }
        try {
            t = jj_consume_token(ID);
            jj_consume_token(EOS);
        } catch (ParseException e) {
            error = true;
            boolean synch = false;
            printParseExc(e);
            while (!synch) {
                switch (getToken(1).kind) {
                    case EOF:
                        synch = true;
                        break;
                    case EOS:
                        synch = true;
                        getNextToken();
                        break;
                    default:
                        getNextToken();
                }
            }
        }
        b = block(scope);
        try {
            if (b == null)
                error = true;
            jj_consume_token(DOT);
        } catch (ParseException e) {
            error = true;
            boolean synch = false;
            printParseExc(e);
            while (!synch) {
                switch (getToken(1).kind) {
                    case EOF:
                        synch = true;
                        break;
                    case DOT:
                        synch = true;
                        getNextToken();
                        break;
                    default:
                        getNextToken();
                }
            }
        }
        if (error) {
            if (true) return null;
        } else {
            if (true) return new Program(t.image, b);
        }
        throw new Error("Missing return statement in function");
    }

    static final public Block block(String scope) throws ParseException {
        int i = 8;
        BlockStatement s;
        Statement aux;
        SymbolTableEntry ste;
        SymbolTable st = SymbolTable.getInstance();
        Block b = new Block("1");
        boolean error = false, retst = false;
        int line = 0, column = 0;
        FunctOrProc faux;

        //Predefined functions

        faux = new Procedure();
        faux.setScope("1-0");
        faux.setBlock(b);
        faux.setSpecialFunc("writeint");
        ste = new SymbolTableEntry("writeint", "1", faux);
        st.addSymbol(ste);
        b.addFunctOrProc(ste);
        ste = new SymbolTableEntry("a", "1-0", new Variable(new IntegerType(), true, false, true));
        st.addSymbol(ste);
        faux.addParameter(ste);

        faux = new Procedure();
        faux.setScope("1-1");
        faux.setBlock(b);
        faux.setSpecialFunc("writeintln");
        ste = new SymbolTableEntry("writeintln", "1", faux);
        st.addSymbol(ste);
        b.addFunctOrProc(ste);
        ste = new SymbolTableEntry("a", "1-1", new Variable(new IntegerType(), true, false, true));
        st.addSymbol(ste);
        faux.addParameter(ste);

        faux = new Procedure();
        faux.setScope("1-2");
        faux.setBlock(b);
        faux.setSpecialFunc("writereal");
        ste = new SymbolTableEntry("writereal", "1", faux);
        st.addSymbol(ste);
        b.addFunctOrProc(ste);
        ste = new SymbolTableEntry("a", "1-2", new Variable(new RealType(), true, false, true));
        st.addSymbol(ste);
        faux.addParameter(ste);

        faux = new Procedure();
        faux.setScope("1-3");
        faux.setBlock(b);
        faux.setSpecialFunc("writerealln");
        ste = new SymbolTableEntry("writerealln", "1", faux);
        st.addSymbol(ste);
        b.addFunctOrProc(ste);
        ste = new SymbolTableEntry("a", "1-3", new Variable(new RealType(), true, false, true));
        st.addSymbol(ste);
        faux.addParameter(ste);

        faux = new Procedure();
        faux.setScope("1-4");
        faux.setBlock(b);
        faux.setSpecialFunc("writechar");
        ste = new SymbolTableEntry("writechar", "1", faux);
        st.addSymbol(ste);
        b.addFunctOrProc(ste);
        ste = new SymbolTableEntry("a", "1-4", new Variable(new CharType(), true, false, true));
        st.addSymbol(ste);
        faux.addParameter(ste);

        faux = new Procedure();
        faux.setScope("1-5");
        faux.setBlock(b);
        faux.setSpecialFunc("writecharln");
        ste = new SymbolTableEntry("writecharln", "1", faux);
        st.addSymbol(ste);
        b.addFunctOrProc(ste);
        ste = new SymbolTableEntry("a", "1-5", new Variable(new CharType(), true, false, true));
        st.addSymbol(ste);
        faux.addParameter(ste);

        faux = new Procedure();
        faux.setScope("1-6");
        faux.setBlock(b);
        faux.setSpecialFunc("writeboolean");
        ste = new SymbolTableEntry("writeboolean", "1", faux);
        st.addSymbol(ste);
        b.addFunctOrProc(ste);
        ste = new SymbolTableEntry("a", "1-6", new Variable(new BooleanType(), true, false, true));
        st.addSymbol(ste);
        faux.addParameter(ste);

        faux = new Procedure();
        faux.setScope("1-7");
        faux.setBlock(b);
        faux.setSpecialFunc("writebooleanln");
        ste = new SymbolTableEntry("writebooleanln", "1", faux);
        st.addSymbol(ste);
        b.addFunctOrProc(ste);
        ste = new SymbolTableEntry("a", "1-7", new Variable(new BooleanType(), true, false, true));
        st.addSymbol(ste);
        faux.addParameter(ste);
        try {
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case CONST:
                    constBlock(scope);
                    break;
                default:
                    jj_la1[0] = jj_gen;
            }
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case TYPE:
                    typeBlock(scope);
                    break;
                default:
                    jj_la1[1] = jj_gen;
            }
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case VAR:
                    varBlock(scope);
                    break;
                default:
                    jj_la1[2] = jj_gen;
            }
            label_1:
            while (true) {
                switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                    case FUNCTION:
                    case PROCEDURE:
                        break;
                    default:
                        jj_la1[3] = jj_gen;
                        break label_1;
                }
                switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                    case FUNCTION:
                        ste = functionBlock(scope, i);
                        i++;
                        b.addFunctOrProc(ste);
                        break;
                    case PROCEDURE:
                        ste = procedureBlock(scope, i);
                        i++;
                        b.addFunctOrProc(ste);
                        break;
                    default:
                        jj_la1[4] = jj_gen;
                        jj_consume_token(-1);
                        throw new ParseException();
                }
            }
            s = new BlockStatement(null);
            jj_consume_token(BEGIN);
            label_2:
            while (true) {
                switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                    case BEGIN:
                    case IF:
                    case WHILE:
                    case CASE:
                    case ID:
                        break;
                    default:
                        jj_la1[5] = jj_gen;
                        break label_2;
                }
                try {
                    aux = statement(scope, null);
                    if (retst) {
                        retst = false;
                        error = true;
                        printError(line, column, "return statement is not placed at the last line of the function");
                    }
                    if (aux == null)
                        error = true;
                    else if (aux.hasReturnStatement() != null) {
                        line = aux.getLine();
                        column = aux.getColumn();
                        retst = true;
                    }
                    s.addStatement(aux);
                    jj_consume_token(EOS);
                } catch (ParseException e) {
                    boolean synch = false;
                    printParseExc(e);
                    while (!synch) {
                        switch (getToken(1).kind) {
                            case END:
                            case EOF:
                                synch = true;
                                break;
                            case EOS:
                                synch = true;
                                getNextToken();
                                break;
                            default:
                                getNextToken();
                        }
                    }
                }
            }
            b.setStatements(s);
            jj_consume_token(END);
        } catch (ParseException e) {
            boolean synch = false;
            printParseExc(e);
            while (!synch) {
                switch (getToken(1).kind) {
                    case DOT:
                    case EOF:
                        synch = true;
                        break;
                    default:
                        getNextToken();
                }
            }
        }
        if (error) {
            if (true) return null;
        } else {
            if (true) return b;
        }
        throw new Error("Missing return statement in function");
    }

    static final public Block funct_block(String scope, String fname) throws ParseException {
        int i = 0;
        BlockStatement s;
        Statement aux;
        SymbolTableEntry ste;
        Block b;
        boolean retst = false, error = false;
        int line = 0, column = 0;
        Token tend;
        b = new Block();
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case CONST:
                constBlock(scope);
                break;
            default:
                jj_la1[6] = jj_gen;
        }
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case TYPE:
                typeBlock(scope);
                break;
            default:
                jj_la1[7] = jj_gen;
        }
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case VAR:
                varBlock(scope);
                break;
            default:
                jj_la1[8] = jj_gen;
        }
        s = new BlockStatement("functOrProc");
        jj_consume_token(BEGIN);
        label_3:
        while (true) {
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case BEGIN:
                case IF:
                case WHILE:
                case CASE:
                case ID:
                    break;
                default:
                    jj_la1[9] = jj_gen;
                    break label_3;
            }
            try {
                aux = statement(scope, fname);
                if (retst) {
                    retst = false;
                    error = true;
                    printError(line, column, "return statement is not placed at the last line of the function");
                }
                if (aux == null)
                    error = true;
                else if (aux.hasReturnStatement() != null) {
                    line = aux.getLine();
                    column = aux.getColumn();
                    retst = true;
                }
                s.addStatement(aux);
                jj_consume_token(EOS);
            } catch (ParseException e) {
                boolean synch = false;
                printParseExc(e);
                while (!synch) {
                    switch (getToken(1).kind) {
                        case END:
                        case EOF:
                            synch = true;
                            break;
                        case EOS:
                            synch = true;
                            getNextToken();
                            break;
                        default:
                            getNextToken();
                    }
                }
            }
        }
        tend = jj_consume_token(END);
        if (fname != null) {
            if (s.hasReturnStatement() == null) {
                error = true;
                printError(tend.beginLine, tend.beginColumn, "function \"" + fname + "\" has no return statement");
            }
        }
        b.setStatements(s);
        if (error) {
            if (true) return null;
        } else {
            if (true) return b;
        }
        throw new Error("Missing return statement in function");
    }

    static final public void constBlock(String scope) throws ParseException {
        boolean error = false;
        Token t;
        Constant c;
        SymbolTable st = SymbolTable.getInstance();
        jj_consume_token(CONST);
        label_4:
        while (true) {
            error = false;
            try {
                t = jj_consume_token(ID);
                if (!st.canBeOveridden(t.image, scope)) {
                    error = true;
                    printError(t.beginLine, t.beginColumn, "identifier \"" + t.image + "\" has been already defined in this scope");
                }
                jj_consume_token(EQ);
                c = constant(scope, null, null);
                if (!error && (c != null))
                    st.addSymbol(new SymbolTableEntry(t.image, scope, c));
                jj_consume_token(EOS);
            } catch (ParseException e) {
                boolean synch = false;
                printParseExc(e);
                while (!synch) {
                    switch (getToken(1).kind) {
                        case TYPE:
                        case VAR:
                        case FUNCTION:
                        case PROCEDURE:
                        case BEGIN:
                        case EOF:
                            synch = true;
                            break;
                        case EOS:
                            synch = true;
                            getNextToken();
                            break;
                        default:
                            getNextToken();
                    }
                }
            }
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case ID:
                    break;
                default:
                    jj_la1[10] = jj_gen;
                    break label_4;
            }
        }
    }

    static final public void typeBlock(String scope) throws ParseException {
        boolean error = false;
        Token t;
        Type tp;
        SymbolTable st = SymbolTable.getInstance();
        jj_consume_token(TYPE);
        label_5:
        while (true) {
            error = false;
            try {
                t = jj_consume_token(ID);
                if (!st.canBeOveridden(t.image, scope)) {
                    error = true;
                    printError(t.beginLine, t.beginColumn, "identifier \"" + t.image + "\" has been already defined in this scope");
                }
                jj_consume_token(EQ);
                tp = typeConst(scope);
                if (!error && (tp != null))
                    st.addSymbol(new SymbolTableEntry(t.image, scope, tp));
                jj_consume_token(EOS);
            } catch (ParseException e) {
                boolean synch = false;
                printParseExc(e);
                while (!synch) {
                    switch (getToken(1).kind) {
                        case VAR:
                        case FUNCTION:
                        case PROCEDURE:
                        case BEGIN:
                        case EOF:
                            synch = true;
                            break;
                        case EOS:
                            synch = true;
                            getNextToken();
                            break;
                        default:
                            getNextToken();
                    }
                }
            }
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case ID:
                    break;
                default:
                    jj_la1[11] = jj_gen;
                    break label_5;
            }
        }
    }

    static final public void varBlock(String scope) throws ParseException {
        Vector v = new Vector();
        Variable var;
        Token t;
        Type tp;
        SymbolTable st = SymbolTable.getInstance();
        boolean isLocal = false;
        if (scope.compareTo("1") != 0)
            isLocal = true;
        jj_consume_token(VAR);
        label_6:
        while (true) {
            try {
                t = jj_consume_token(ID);
                v.add(t);
                label_7:
                while (true) {
                    switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                        case COMMA:
                            break;
                        default:
                            jj_la1[12] = jj_gen;
                            break label_7;
                    }
                    jj_consume_token(COMMA);
                    t = jj_consume_token(ID);
                    v.add(t);
                }
                jj_consume_token(COLON);
                tp = typeConst(scope);
                for (int i = 0; i < v.size(); i++) {
                    t = (Token) v.elementAt(i);
                    var = new Variable(tp, false, false, isLocal);
                    if (!st.canBeOveridden(t.image, scope)) {
                        printError(t.beginLine, t.beginColumn, "identifier \"" + t.image + "\" has been already defined in this scope");
                    } else if (tp != null)
                        st.addSymbol(new SymbolTableEntry(t.image, scope, var));
                }
                v = new Vector();
                jj_consume_token(EOS);
            } catch (ParseException e) {
                boolean synch = false;
                printParseExc(e);
                while (!synch) {
                    switch (getToken(1).kind) {
                        case FUNCTION:
                        case PROCEDURE:
                        case BEGIN:
                        case EOF:
                            synch = true;
                            break;
                        case EOS:
                            synch = true;
                            getNextToken();
                            break;
                        default:
                            getNextToken();
                    }
                }
            }
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case ID:
                    break;
                default:
                    jj_la1[13] = jj_gen;
                    break label_6;
            }
        }
    }

    static final public SymbolTableEntry functionBlock(String fscope, int fnumber) throws ParseException {
        boolean error = false;
        IntWrapper errorInt = new IntWrapper();
        Token t;
        Type tp;
        Function f;
        Block b;
        String scope = fscope + "-" + fnumber;
        SymbolTable st = SymbolTable.getInstance();
        SymbolTableEntry ste = null;
        Token tcolon;
        errorInt.setValue(0);
        jj_consume_token(FUNCTION);
        try {
            t = jj_consume_token(ID);
            f = new Function();
            f.setScope(scope);
            if (!st.canBeOveridden(t.image, fscope)) {
                error = true;
                printError(t.beginLine, t.beginColumn, "identifier \"" + t.image + "\" has been already defined in this scope");
            }
            parameterList(f, scope, fscope, errorInt);
            if (errorInt.getValue() == -1)
                error = true;
            tcolon = jj_consume_token(COLON);
            tp = typeConst(scope);
            if (tp == null)
                error = true;
            else if (tp instanceof ArrayType) {
                error = true;
                printError(tcolon.beginLine, tcolon.beginColumn, "a function cannot return an array");
            } else
                f.setReturnType(tp);
            if (!error) {
                ste = new SymbolTableEntry(t.image, fscope, f);
                st.addSymbol(ste);
            }
            jj_consume_token(EOS);
            b = funct_block(scope, t.image);
            f.setBlock(b);
            jj_consume_token(EOS);
        } catch (ParseException e) {
            boolean synch = false;
            printParseExc(e);
            while (!synch) {
                switch (getToken(1).kind) {
                    case FUNCTION:
                    case PROCEDURE:
                    case BEGIN:
                    case EOF:
                        synch = true;
                        break;
                    default:
                        getNextToken();
                }
            }
        }
        if (error) {
            if (true) return null;
        } else {
            if (true) return ste;
        }
        throw new Error("Missing return statement in function");
    }

    static final public SymbolTableEntry procedureBlock(String fscope, int fnumber) throws ParseException {
        boolean error = false;
        Procedure p;
        Token t;
        Block b;
        String scope = fscope + "-" + fnumber;
        SymbolTable st = SymbolTable.getInstance();
        SymbolTableEntry ste = null;
        IntWrapper errorInt = new IntWrapper();
        errorInt.setValue(0);
        jj_consume_token(PROCEDURE);
        try {
            t = jj_consume_token(ID);
            p = new Procedure();
            p.setScope(scope);
            if (!st.canBeOveridden(t.image, fscope)) {
                error = true;
                printError(t.beginLine, t.beginColumn, "identifier \"" + t.image + "\" has been already defined in this scope");
            }
            parameterList(p, scope, fscope, errorInt);
            if (errorInt.getValue() == -1)
                error = true;
            if (!error) {
                ste = new SymbolTableEntry(t.image, fscope, p);
                st.addSymbol(ste);
            }
            jj_consume_token(EOS);
            b = funct_block(scope, null);
            p.setBlock(b);
            jj_consume_token(EOS);
        } catch (ParseException e) {
            boolean synch = false;
            printParseExc(e);
            while (!synch) {
                switch (getToken(1).kind) {
                    case FUNCTION:
                    case PROCEDURE:
                    case BEGIN:
                    case EOF:
                        synch = true;
                        break;
                    default:
                        getNextToken();
                }
            }
        }
        if (error) {
            if (true) return null;
        } else {
            if (true) return ste;
        }
        throw new Error("Missing return statement in function");
    }

    static final public Constant constant(String scope, IntWrapper line, IntWrapper column) throws ParseException {
        boolean error = false;
        Token t = null, sign = null;
        Constant c = null;
        SymbolTable st = SymbolTable.getInstance();
        SymbolTableEntry ste;
        boolean identifier = false;
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case PLUS:
            case MINUS:
            case ID:
            case UNS_INT:
            case UNS_NUM:
                switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                    case PLUS:
                    case MINUS:
                        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                            case PLUS:
                                sign = jj_consume_token(PLUS);
                                break;
                            case MINUS:
                                sign = jj_consume_token(MINUS);
                                break;
                            default:
                                jj_la1[14] = jj_gen;
                                jj_consume_token(-1);
                                throw new ParseException();
                        }
                        break;
                    default:
                        jj_la1[15] = jj_gen;
                }
                switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                    case ID:
                        t = jj_consume_token(ID);
                        identifier = true;
                        ste = st.getSymbol(t.image, scope);
                        if (ste == null) {
                            error = true;
                            printError(t.beginLine, t.beginColumn, "identifier \"" + t.image + "\" is not defined");
                        } else if (ste.getObject() instanceof Constant)
                            c = (Constant) ste.getObject();
                        else {
                            error = true;
                            printError(t.beginLine, t.beginColumn, "identifier \"" + t.image + "\" does not represent a constant");
                        }
                        break;
                    case UNS_NUM:
                        t = jj_consume_token(UNS_NUM);
                        c = new RealConstant();
                        break;
                    case UNS_INT:
                        t = jj_consume_token(UNS_INT);
                        c = new IntegerConstant();
                        break;
                    default:
                        jj_la1[16] = jj_gen;
                        jj_consume_token(-1);
                        throw new ParseException();
                }
                break;
            case STLIT:
                t = jj_consume_token(STLIT);
                //if(t.image.length() == 3)
                c = new CharConstant();
                //else
                //c = new StringConstant();

                break;
            case TRUE:
            case FALSE:
                switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                    case TRUE:
                        t = jj_consume_token(TRUE);
                        break;
                    case FALSE:
                        t = jj_consume_token(FALSE);
                        break;
                    default:
                        jj_la1[17] = jj_gen;
                        jj_consume_token(-1);
                        throw new ParseException();
                }
                c = new BooleanConstant();
                break;
            default:
                jj_la1[18] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
        //it sets the values for the starting line and column
        if (line != null) {
            if (sign != null) {
                line.setValue(sign.beginLine);
                column.setValue(sign.beginColumn);
            } else {
                line.setValue(t.beginLine);
                column.setValue(t.beginColumn);
            }
        }
        if (!identifier && !error) {
            if (sign == null)
                c.storePascalValue(t.beginLine, t.beginColumn, t.image);
            else
                c.storePascalValue(sign.beginLine, sign.beginColumn, sign.image + t.image);
        }
        if (error) {
            if (true) return null;
        } else {
            if (true) return c;
        }
        throw new Error("Missing return statement in function");
    }

    static final public Constant uns_constant(String scope) throws ParseException {
        Token t = null;
        Constant c = null;
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case UNS_NUM:
                t = jj_consume_token(UNS_NUM);
                c = new RealConstant();
                break;
            case UNS_INT:
                t = jj_consume_token(UNS_INT);
                c = new IntegerConstant();
                break;
            case STLIT:
                t = jj_consume_token(STLIT);
                //if(t.image.length() == 3)
                c = new CharConstant();
                //else
                //c = new StringConstant();

                break;
            case TRUE:
            case FALSE:
                switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                    case TRUE:
                        t = jj_consume_token(TRUE);
                        break;
                    case FALSE:
                        t = jj_consume_token(FALSE);
                        break;
                    default:
                        jj_la1[19] = jj_gen;
                        jj_consume_token(-1);
                        throw new ParseException();
                }
                c = new BooleanConstant();
                break;
            default:
                jj_la1[20] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
        c.storePascalValue(t.beginLine, t.beginColumn, t.image);
        {
            if (true) return c;
        }
        throw new Error("Missing return statement in function");
    }

    static final public Type typeConst(String scope) throws ParseException {
        boolean error = false, currentError = false;
        Type tp = null, tp2;
        Token t = null, sign = null, t2 = null, auxTok = null;
        int min = 0, max = 0, i = 0;
        SymbolTable st = SymbolTable.getInstance();
        SymbolTableEntry ste = null;
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case INTEGER:
                jj_consume_token(INTEGER);
                tp = new IntegerType();
                break;
            case REAL:
                jj_consume_token(REAL);
                tp = new RealType();
                break;
            case BOOLEAN:
                jj_consume_token(BOOLEAN);
                tp = new BooleanType();
                break;
            case CHAR:
                jj_consume_token(CHAR);
                tp = new CharType();
                break;
            case ID:
                t = jj_consume_token(ID);
                ste = st.getSymbol(t.image, scope);
                if (ste == null) {
                    error = true;
                    printError(t.beginLine, t.beginColumn, "identifier \"" + t.image + "\" is not defined");
                } else if (ste.getObject() instanceof Type)
                    tp = (Type) ste.getObject();
                else {
                    error = true;
                    printError(t.beginLine, t.beginColumn, "identifier \"" + t.image + "\" does not represent a type");
                }
                break;
            case ARRAY:
                jj_consume_token(ARRAY);
                t2 = jj_consume_token(OP_BRAC);
                tp = new ArrayType();
                switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                    case PLUS:
                    case MINUS:
                        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                            case PLUS:
                                sign = jj_consume_token(PLUS);
                                break;
                            case MINUS:
                                sign = jj_consume_token(MINUS);
                                break;
                            default:
                                jj_la1[21] = jj_gen;
                                jj_consume_token(-1);
                                throw new ParseException();
                        }
                        break;
                    default:
                        jj_la1[22] = jj_gen;
                }
                t = jj_consume_token(UNS_INT);
                if (sign != null)
                    auxTok = sign;
                else
                    auxTok = t;
                try {
                    if (sign == null)
                        min = Integer.parseInt(t.image);
                    else
                        min = Integer.parseInt(sign.image + t.image);
                } catch (NumberFormatException e) {
                    error = true;
                    printError(auxTok.beginLine, auxTok.beginColumn, "number exceeds INTEGER range");
                }
                sign = null;
                jj_consume_token(DDOT);
                switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                    case PLUS:
                    case MINUS:
                        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                            case PLUS:
                                sign = jj_consume_token(PLUS);
                                break;
                            case MINUS:
                                sign = jj_consume_token(MINUS);
                                break;
                            default:
                                jj_la1[23] = jj_gen;
                                jj_consume_token(-1);
                                throw new ParseException();
                        }
                        break;
                    default:
                        jj_la1[24] = jj_gen;
                }
                t = jj_consume_token(UNS_INT);
                if (sign != null)
                    auxTok = sign;
                else
                    auxTok = t;
                try {
                    if (sign == null)
                        max = Integer.parseInt(t.image);
                    else
                        max = Integer.parseInt(sign.image + t.image);
                } catch (NumberFormatException e) {
                    error = true;
                    printError(auxTok.beginLine, auxTok.beginColumn, "number exceeds INTEGER range");
                }
                sign = null;
                if (!error) {
                    if (max >= min)
                        ((ArrayType) tp).setDimensions(i, min, max);
                    else {
                        error = true;
                        printError(t2.beginLine, t2.beginColumn, "lower bound greater than upper bound");
                    }
                    i++;
                }
                label_8:
                while (true) {
                    switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                        case COMMA:
                            break;
                        default:
                            jj_la1[25] = jj_gen;
                            break label_8;
                    }
                    t2 = jj_consume_token(COMMA);
                    currentError = false;
                    switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                        case PLUS:
                        case MINUS:
                            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                                case PLUS:
                                    sign = jj_consume_token(PLUS);
                                    break;
                                case MINUS:
                                    sign = jj_consume_token(MINUS);
                                    break;
                                default:
                                    jj_la1[26] = jj_gen;
                                    jj_consume_token(-1);
                                    throw new ParseException();
                            }
                            break;
                        default:
                            jj_la1[27] = jj_gen;
                    }
                    t = jj_consume_token(UNS_INT);
                    if (sign != null)
                        auxTok = sign;
                    else
                        auxTok = t;
                    try {
                        if (sign == null)
                            min = Integer.parseInt(t.image);
                        else
                            min = Integer.parseInt(sign.image + t.image);
                    } catch (NumberFormatException e) {
                        currentError = true;
                        error = true;
                        printError(auxTok.beginLine, auxTok.beginColumn, "number exceeds INTEGER range");
                    }
                    sign = null;
                    jj_consume_token(DDOT);
                    switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                        case PLUS:
                        case MINUS:
                            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                                case PLUS:
                                    sign = jj_consume_token(PLUS);
                                    break;
                                case MINUS:
                                    sign = jj_consume_token(MINUS);
                                    break;
                                default:
                                    jj_la1[28] = jj_gen;
                                    jj_consume_token(-1);
                                    throw new ParseException();
                            }
                            break;
                        default:
                            jj_la1[29] = jj_gen;
                    }
                    t = jj_consume_token(UNS_INT);
                    if (sign != null)
                        auxTok = sign;
                    else
                        auxTok = t;
                    try {
                        if (sign == null)
                            max = Integer.parseInt(t.image);
                        else
                            max = Integer.parseInt(sign.image + t.image);
                    } catch (NumberFormatException e) {
                        currentError = true;
                        error = true;
                        printError(auxTok.beginLine, auxTok.beginColumn, "number exceeds INTEGER range");
                    }
                    sign = null;
                    if (!currentError) {
                        if (max >= min)
                            ((ArrayType) tp).setDimensions(i, min, max);
                        else {
                            error = true;
                            printError(t2.beginLine, t2.beginColumn, "lower bound greater than upper bound");
                        }
                        i++;
                    }
                }
                jj_consume_token(CL_BRAC);
                jj_consume_token(OF);
                tp2 = typeConst(scope);
                if (tp2 == null)
                    error = true;
                if (!error)
                    ((ArrayType) tp).setElsType(tp2);
                break;
            default:
                jj_la1[30] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
        if (!error) {
            if (true) return tp;
        } else {
            if (true) return null;
        }
        throw new Error("Missing return statement in function");
    }

    static final public void parameterList(FunctOrProc funcNode, String scope, String fscope, IntWrapper errorInt) throws ParseException {
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case OP_PAR:
                jj_consume_token(OP_PAR);
                try {
                    subParList(funcNode, scope, fscope, errorInt);
                    label_9:
                    while (true) {
                        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                            case EOS:
                                break;
                            default:
                                jj_la1[31] = jj_gen;
                                break label_9;
                        }
                        jj_consume_token(EOS);
                        subParList(funcNode, scope, fscope, errorInt);
                    }
                    jj_consume_token(CL_PAR);
                } catch (ParseException e) {
                    errorInt.setValue(-1);
                    boolean synch = false;
                    printParseExc(e);
                    while (!synch) {
                        switch (getToken(1).kind) {
                            case CL_PAR:
                                synch = true;
                                getNextToken();
                                break;
                            case EOF:
                                synch = true;
                                break;
                            default:
                                getNextToken();
                        }
                    }
                }
                break;
            default:
                jj_la1[32] = jj_gen;
        }
    }

    static final public void subParList(FunctOrProc funcNode, String scope, String fscope, IntWrapper errorInt) throws ParseException {
        Token t;
        boolean isOutput = false;
        Variable var;
        Vector v = new Vector();
        Type tp;
        SymbolTable st = SymbolTable.getInstance();
        SymbolTableEntry ste;
        try {
            //(<VAR> { isOutput = true; }  )?
            t = jj_consume_token(ID);
            v.add(t);
            label_10:
            while (true) {
                switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                    case COMMA:
                        break;
                    default:
                        jj_la1[33] = jj_gen;
                        break label_10;
                }
                jj_consume_token(COMMA);
                t = jj_consume_token(ID);
                v.add(t);
            }
            jj_consume_token(COLON);
            tp = typeConst(fscope);
            if (tp == null)
                errorInt.setValue(-1);
            else {
                for (int i = 0; i < v.size(); i++) {
                    t = (Token) v.elementAt(i);
                    if (!st.canBeOveridden(t.image, scope)) {
                        printError(t.beginLine, t.beginColumn, "identifier \"" + t.image + "\" has been already defined in this scope");
                    } else {
                        var = new Variable(tp, true, isOutput, true);
                        ste = new SymbolTableEntry(t.image, scope, var);
                        st.addSymbol(ste);
                        funcNode.addParameter(ste);
                    }
                }
            }
            v = new Vector();
        } catch (ParseException e) {
            errorInt.setValue(-1);
            boolean synch = false;
            printParseExc(e);
            while (!synch) {
                switch (getToken(1).kind) {
                    case CL_PAR:
                    case EOS:
                    case EOF:
                        synch = true;
                        break;
                    default:
                        getNextToken();
                }
            }
        }
    }

    static final public Expression expression(String scope) throws ParseException {
        boolean error = false;
        Token t;
        SimpleExpression se, prevse;
        Expression e;
        Operator op;
        Type prevType = null;
        se = simpExpression(scope);
        if (se == null)
            error = true;
        else
            prevType = se.getType();
        e = new Expression(se);
        label_11:
        while (true) {
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case LT:
                case GT:
                case EQ:
                case LET:
                case GET:
                case NE:
                    break;
                default:
                    jj_la1[34] = jj_gen;
                    break label_11;
            }
            op = new CompareOperator();
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case EQ:
                    t = jj_consume_token(EQ);
                    break;
                case LT:
                    t = jj_consume_token(LT);
                    break;
                case GT:
                    t = jj_consume_token(GT);
                    break;
                case NE:
                    t = jj_consume_token(NE);
                    break;
                case LET:
                    t = jj_consume_token(LET);
                    break;
                case GET:
                    t = jj_consume_token(GET);
                    break;
                default:
                    jj_la1[35] = jj_gen;
                    jj_consume_token(-1);
                    throw new ParseException();
            }
            op.setKind(t.image);
            se = simpExpression(scope);
            if (!error) {
                if (se == null)
                    error = true;
                else if (prevType != null) {
                    if (op.resultType(prevType, se.getType()) == null) {
                        error = true;
                        printError(t.beginLine, t.beginColumn, "operator \"" + t.image + "\" cannot be applied between " + prevType + " and " + se.getType());
                    }
                    prevType = op.resultType(prevType, se.getType());
                    e.addOtherExpr(op, se);
                }
            }
        }
        if (error) {
            if (true) return null;
        } else {
            if (true) return e;
        }
        throw new Error("Missing return statement in function");
    }

    static final public SimpleExpression simpExpression(String scope) throws ParseException {
        boolean error = false;
        Token t = null;
        Operator op = null;
        Term te, prevte;
        SimpleExpression se;
        Type prevType = null;
        op = new NormalArithOperator();
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case PLUS:
            case MINUS:
                switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                    case PLUS:
                        t = jj_consume_token(PLUS);
                        break;
                    case MINUS:
                        t = jj_consume_token(MINUS);
                        break;
                    default:
                        jj_la1[36] = jj_gen;
                        jj_consume_token(-1);
                        throw new ParseException();
                }
                break;
            default:
                jj_la1[37] = jj_gen;
        }
        if (t == null)
            op = null;
        else
            op.setKind(t.image);
        te = term(scope);
        if (te == null)
            error = true;
        else if (op != null) {
            if (op.resultType(te.getType()) == null) {
                error = true;
                printError(t.beginLine, t.beginColumn, "operator \"" + t.image + "\" cannot be applied to " + te.getType());
            } else
                prevType = op.resultType(te.getType());
        } else
            prevType = te.getType();
        se = new SimpleExpression(op, te);
        label_12:
        while (true) {
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case PLUS:
                case MINUS:
                case OR:
                    break;
                default:
                    jj_la1[38] = jj_gen;
                    break label_12;
            }
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case PLUS:
                    t = jj_consume_token(PLUS);
                    op = new NormalArithOperator();
                    break;
                case MINUS:
                    t = jj_consume_token(MINUS);
                    op = new NormalArithOperator();
                    break;
                case OR:
                    t = jj_consume_token(OR);
                    op = new LogicalOperator();
                    break;
                default:
                    jj_la1[39] = jj_gen;
                    jj_consume_token(-1);
                    throw new ParseException();
            }
            op.setKind(t.image);
            te = term(scope);
            if (!error) {
                if (te == null)
                    error = true;
                else if (prevType != null) {
                    if (op.resultType(prevType, te.getType()) == null) {
                        error = true;
                        printError(t.beginLine, t.beginColumn, "operator \"" + t.image + "\" cannot be applied between " + prevType + " and " + te.getType());
                    }
                    prevType = op.resultType(prevType, te.getType());
                    se.addOtherTerm(op, te);
                }
            }
        }
        if (error) {
            if (true) return null;
        } else {
            if (true) return se;
        }
        throw new Error("Missing return statement in function");
    }

    static final public Term term(String scope) throws ParseException {
        boolean error = false;
        Term tm;
        Token t;
        Operator op;
        Factor f, prevf;
        Type prevType = null;
        f = factor(scope);
        if (f == null)
            error = true;
        else
            prevType = f.getType();
        tm = new Term(f);
        label_13:
        while (true) {
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case MULT:
                case DIV:
                case MOD:
                case DIVR:
                case AND:
                    break;
                default:
                    jj_la1[40] = jj_gen;
                    break label_13;
            }
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case MULT:
                    t = jj_consume_token(MULT);
                    op = new NormalArithOperator();
                    break;
                case DIVR:
                    t = jj_consume_token(DIVR);
                    op = new RealDivisionOperator();
                    break;
                case DIV:
                    t = jj_consume_token(DIV);
                    op = new IntegerArithOperator();
                    break;
                case MOD:
                    t = jj_consume_token(MOD);
                    op = new IntegerArithOperator();
                    break;
                case AND:
                    t = jj_consume_token(AND);
                    op = new LogicalOperator();
                    break;
                default:
                    jj_la1[41] = jj_gen;
                    jj_consume_token(-1);
                    throw new ParseException();
            }
            op.setKind(t.image);
            f = factor(scope);
            if (!error) {
                if (f == null)
                    error = true;
                else if (prevType != null) {
                    if (op.resultType(prevType, f.getType()) == null) {
                        error = true;
                        printError(t.beginLine, t.beginColumn, "operator \"" + t.image + "\" cannot be applied between " + prevType + " and " + f.getType());
                    }
                    prevType = op.resultType(prevType, f.getType());
                    tm.addOtherFactor(op, f);
                }
            }
        }
        if (error) {
            if (true) return null;
        } else {
            if (true) return tm;
        }
        throw new Error("Missing return statement in function");
    }

    static final public Factor factor(String scope) throws ParseException {
        boolean error = false;
        FactorObject fo = null;
        int i = 0;
        Token t, t2, idtok;
        Factor f = null;
        Expression e = null;
        FunctionCall fc = null;
        VariableApparition v = null, vAux = null;
        SymbolTable st = SymbolTable.getInstance();
        SymbolTableEntry ste = null;
        Type type;
        int dims = 0;
        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
            case TRUE:
            case FALSE:
            case UNS_INT:
            case UNS_NUM:
            case STLIT:
                fo = uns_constant(scope);
                break;
            case ID:
                t = jj_consume_token(ID);
                idtok = t;
                ste = st.getSymbol(t.image, scope);
                if (ste == null) {
                    error = true;
                    printError(t.beginLine, t.beginColumn, "identifier \"" + t.image + "\" is not defined");
                }
                switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                    case OP_BRAC:
                    case OP_PAR:
                        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                            case OP_BRAC:
                                if (!error) {
                                    if (ste.getObject() instanceof Variable) {
                                        v = new VariableApparition(ste);
                                    } else {
                                        error = true;
                                        printError(t.beginLine, t.beginColumn, "identifier \"" + t.image + "\" does not represent a variable");
                                    }
                                }
                                label_14:
                                while (true) {
                                    t = jj_consume_token(OP_BRAC);
                                    i = 0;
                                    if (!error) {
                                        type = v.getType();
                                        if (!type.isIndexable()) {
                                            error = true;
                                            printError(t.beginLine, t.beginColumn, "this variable cannot be indexed");
                                        } else {
                                            if (type instanceof ArrayType) {
                                                ArrayType at = (ArrayType) type;
                                                dims = at.getNumberOfDimensions();
                                            }
                                                        /*else if(type instanceof StringType)
							{
								dims = 1;
							}*/
                                            v = new IndexedVariable(v);
                                        }
                                    }
                                    try {
                                        e = null;
                                        e = expression(scope);
                                        if (e == null)
                                            error = true;
                                    } catch (ParseException exc) {
                                        error = true;
                                        boolean synch = false;
                                        printParseExc(exc);
                                        while (!synch) {
                                            switch (getToken(1).kind) {
                                                case COMMA:
                                                case CL_BRAC:
                                                case EOS:
                                                case END:
                                                case EOF:
                                                    synch = true;
                                                    break;
                                                default:
                                                    getNextToken();
                                            }
                                        }
                                    }
                                    if (e != null && !error) {
                                        if (i < dims) {
                                            Type intType = new IntegerType();
                                            if (intType.isCompatibleWith(e.getType())) {
                                                                /*
								Controlling if the indices are out of bounds will make necessary evaluation
								of expressions at compile time.
								*/
                                                ((IndexedVariable) v).setIndex(i, e);
                                                i++;
                                            } else {
                                                error = true;
                                                printError(t.beginLine, t.beginColumn, "this expression is not of type integer");
                                            }
                                        } else {
                                            error = true;
                                            printError(t.beginLine, t.beginColumn, "too many indexes for this bracket");
                                        }
                                    }
                                    label_15:
                                    while (true) {
                                        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                                            case COMMA:
                                                break;
                                            default:
                                                jj_la1[42] = jj_gen;
                                                break label_15;
                                        }
                                        t2 = jj_consume_token(COMMA);
                                        try {
                                            e = null;
                                            e = expression(scope);
                                            if (e == null)
                                                error = true;
                                        } catch (ParseException exc) {
                                            error = true;
                                            boolean synch = false;
                                            printParseExc(exc);
                                            while (!synch) {
                                                switch (getToken(1).kind) {
                                                    case COMMA:
                                                    case CL_BRAC:
                                                    case EOS:
                                                    case END:
                                                    case EOF:
                                                        synch = true;
                                                        break;
                                                    default:
                                                        getNextToken();
                                                }
                                            }
                                        }
                                        if (e != null && !error) {
                                            if (i < dims) {
                                                Type intType = new IntegerType();
                                                if (intType.isCompatibleWith(e.getType())) {
                                                                        /*
									Controlling if the indices are out of bounds will make necessary evaluation
									of expressions at compile time.
									*/
                                                    ((IndexedVariable) v).setIndex(i, e);
                                                    i++;
                                                } else {
                                                    error = true;
                                                    printError(t2.beginLine, t2.beginColumn, "this expression is not of type integer");
                                                }
                                            } else {
                                                error = true;
                                                printError(t.beginLine, t.beginColumn, "too many indexes for this bracket");
                                            }
                                        }
                                    }
                                    jj_consume_token(CL_BRAC);
                                    if (!error && (i < dims)) {
                                        error = true;
                                        printError(t.beginLine, t.beginColumn, "not enough indexes for this bracket");
                                    }
                                    switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                                        case OP_BRAC:
                                            break;
                                        default:
                                            jj_la1[43] = jj_gen;
                                            break label_14;
                                    }
                                }
                                if (v.getType() instanceof ArrayType) {
                                    error = true;
                                    printError(idtok.beginLine, idtok.beginColumn, "array not completely indexed");
                                }
                                if (!error)
                                    fo = v;
                                else
                                    fo = null;
                                break;
                            case OP_PAR:
                                jj_consume_token(OP_PAR);
                                if (!error) {
                                    if (ste.getObject() instanceof FunctOrProc)
                                        fc = new FunctionCall(ste);
                                    else {
                                        error = true;
                                        printError(t.beginLine, t.beginColumn, "this is not a callable object");
                                    }
                                }
                                try {
                                    e = null;
                                    e = expression(scope);
                                    if (e == null)
                                        error = true;
                                } catch (ParseException exc) {
                                    error = true;
                                    boolean synch = false;
                                    printParseExc(exc);
                                    while (!synch) {
                                        switch (getToken(1).kind) {
                                            case COMMA:
                                            case CL_PAR:
                                            case EOS:
                                            case END:
                                            case EOF:
                                                synch = true;
                                                break;
                                            default:
                                                getNextToken();
                                        }
                                    }
                                }
                                if (!error) {
                                    fc.setParameter(i, e);
                                    i++;
                                }
                                label_16:
                                while (true) {
                                    switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                                        case COMMA:
                                            break;
                                        default:
                                            jj_la1[44] = jj_gen;
                                            break label_16;
                                    }
                                    jj_consume_token(COMMA);
                                    try {
                                        e = null;
                                        e = expression(scope);
                                        if (e == null)
                                            error = true;
                                    } catch (ParseException exc) {
                                        error = true;
                                        boolean synch = false;
                                        printParseExc(exc);
                                        while (!synch) {
                                            switch (getToken(1).kind) {
                                                case COMMA:
                                                case CL_PAR:
                                                case EOS:
                                                case END:
                                                case EOF:
                                                    synch = true;
                                                    break;
                                                default:
                                                    getNextToken();
                                            }
                                        }
                                    }
                                    if (!error) {
                                        fc.setParameter(i, e);
                                        i++;
                                    }
                                }
                                jj_consume_token(CL_PAR);
                                if (!error) {
                                    if (!fc.isCorrect()) {
                                        error = true;
                                        printError(t.beginLine, t.beginColumn, fc.toString() + " cannot be applied to " + fc.getFunctionString());
                                    } else if (ste.getObject() instanceof Procedure) {
                                        error = true;
                                        printError(t.beginLine, t.beginColumn, "\"" + t.image + "\" is a procedure: procedures cannot be called here");
                                    } else
                                        fo = fc;
                                }
                                break;
                            default:
                                jj_la1[45] = jj_gen;
                                jj_consume_token(-1);
                                throw new ParseException();
                        }
                        break;
                    default:
                        jj_la1[46] = jj_gen;
                }
                if (!error && fo == null) {
                    if (ste.getObject() instanceof Variable)
                        fo = new VariableApparition(ste);
                    else if (ste.getObject() instanceof FunctOrProc) {
                        FunctionCall fcAux = new FunctionCall(ste);
                        if (!fcAux.isCorrect()) {
                            error = true;
                            printError(idtok.beginLine, idtok.beginColumn, fcAux.toString() + " cannot be applied to " + fcAux.getFunctionString());
                        }
                        if (ste.getObject() instanceof Procedure) {
                            error = true;
                            printError(t.beginLine, t.beginColumn, "\"" + t.image + "\" is a procedure : procedures cannot be called here");
                        }
                        if (!error)
                            fo = fcAux;
                    } else if (ste.getObject() instanceof Constant)
                        fo = (FactorObject) ste.getObject();
                    else {
                        error = true;
                        printError(t.beginLine, t.beginColumn, "identifier \"" + t.image + "\" does not represent either a function or a variable");
                    }
                }
                break;
            case OP_PAR:
                jj_consume_token(OP_PAR);
                try {
                    fo = expression(scope);
                } catch (ParseException exc) {
                    boolean synch = false;
                    printParseExc(exc);
                    while (!synch) {
                        switch (getToken(1).kind) {
                            case CL_PAR:
                            case EOS:
                            case END:
                            case EOF:
                                synch = true;
                                break;
                            default:
                                getNextToken();
                        }
                    }
                }
                jj_consume_token(CL_PAR);
                break;
            case NOT:
                jj_consume_token(NOT);
                f = factor(scope);
                if (f != null) {
                    if (f.getPrevOperator() != null)
                        f.setPrevOperator(null); //two not operations become nothing
                    else {
                        Operator op = new LogicalOperator();
                        op.setKind("not");
                        f.setPrevOperator(op);
                    }
                }
                break;
            default:
                jj_la1[47] = jj_gen;
                jj_consume_token(-1);
                throw new ParseException();
        }
        if (f == null && fo != null && !error) {
            f = new Factor();
            f.setFactor(fo);
        }
        {
            if (true) return f;
        }
        throw new Error("Missing return statement in function");
    }

    static final public Statement statement(String scope, String fname) throws ParseException {
        boolean error = false;
        Token t, t2, idtok;
        FunctionCall fc = null;
        Statement s = null, aux = null;
        VariableApparition v = null;
        Expression e = null;
        SymbolTable st = SymbolTable.getInstance();
        SymbolTableEntry ste = null;
        int i = 0, dims = 0;
        Type exprType = null, type = null;
        boolean retst;
        try {
            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                case ID:
                    t = jj_consume_token(ID);
                    idtok = t;
                    ste = st.getSymbol(t.image, scope);
                    if (ste == null) {
                        error = true;
                        printError(t.beginLine, t.beginColumn, "identifier \"" + t.image + "\" is not defined");
                    }
                    switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                        case OP_BRAC:
                        case OP_PAR:
                        case ASSIGN:
                            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                                case OP_PAR:
                                    jj_consume_token(OP_PAR);
                                    if (!error) {
                                        if (ste.getObject() instanceof FunctOrProc) {
                                            fc = new FunctionCall(ste);
                                            s = new FunctionCallStatement(fc);
                                        } else {
                                            error = true;
                                            printError(t.beginLine, t.beginColumn, "this is not a callable object");
                                        }
                                    }
                                    try {
                                        e = null;
                                        e = expression(scope);
                                        if (e == null)
                                            error = true;
                                    } catch (ParseException exc) {
                                        error = true;
                                        boolean synch = false;
                                        printParseExc(exc);
                                        while (!synch) {
                                            switch (getToken(1).kind) {
                                                case COMMA:
                                                case CL_PAR:
                                                case EOS:
                                                case END:
                                                case EOF:
                                                    synch = true;
                                                    break;
                                                default:
                                                    getNextToken();
                                            }
                                        }
                                    }
                                    if (!error) {
                                        fc.setParameter(i, e);
                                        i++;
                                    }
                                    label_17:
                                    while (true) {
                                        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                                            case COMMA:
                                                break;
                                            default:
                                                jj_la1[48] = jj_gen;
                                                break label_17;
                                        }
                                        jj_consume_token(COMMA);
                                        try {
                                            e = null;
                                            e = expression(scope);
                                            if (e == null)
                                                error = true;
                                        } catch (ParseException exc) {
                                            error = true;
                                            boolean synch = false;
                                            printParseExc(exc);
                                            while (!synch) {
                                                switch (getToken(1).kind) {
                                                    case COMMA:
                                                    case CL_PAR:
                                                    case EOS:
                                                    case END:
                                                    case EOF:
                                                        synch = true;
                                                        break;
                                                    default:
                                                        getNextToken();
                                                }
                                            }
                                        }
                                        if (!error) {
                                            fc.setParameter(i, e);
                                            i++;
                                        }
                                    }
                                    jj_consume_token(CL_PAR);
                                    if (!error) {
                                        if (!fc.isCorrect()) {
                                            error = true;
                                            printError(t.beginLine, t.beginColumn, fc.toString() + " cannot be applied to " + fc.getFunctionString());
                                        }
                                        if (ste.getObject() instanceof Function) {
                                            error = true;
                                            printError(t.beginLine, t.beginColumn, "\"" + t.image + "\" is a function, but its return value it is not used");
                                        }
                                    }
                                    break;
                                case OP_BRAC:
                                case ASSIGN:
                                    v = null;
                                    if (!error) {
                                        if (ste.getObject() instanceof Variable) {
                                            v = new VariableApparition(ste);
                                        } else if (!(ste.getObject() instanceof Function)) {
                                            error = true;
                                            printError(t.beginLine, t.beginColumn, "identifier \"" + t.image + "\" does not represent a variable");
                                        }
                                    }
                                    label_18:
                                    while (true) {
                                        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                                            case OP_BRAC:
                                                break;
                                            default:
                                                jj_la1[49] = jj_gen;
                                                break label_18;
                                        }
                                        //for variables
                                        t = jj_consume_token(OP_BRAC);
                                        i = 0;
                                        if (!error) {
                                            type = v.getType();
                                            if (!type.isIndexable()) {
                                                error = true;
                                                printError(t.beginLine, t.beginColumn, "this variable cannot be indexed");
                                            } else {
                                                if (type instanceof ArrayType) {
                                                    ArrayType at = (ArrayType) type;
                                                    dims = at.getNumberOfDimensions();
                                                }
                                                                /*else if(type instanceof StringType)
								{
									dims = 1;
								}*/
                                                v = new IndexedVariable(v);
                                            }
                                        }
                                        try {
                                            e = null;
                                            e = expression(scope);
                                            if (e == null)
                                                error = true;
                                        } catch (ParseException exc) {
                                            error = true;
                                            boolean synch = false;
                                            printParseExc(exc);
                                            while (!synch) {
                                                switch (getToken(1).kind) {
                                                    case COMMA:
                                                    case CL_BRAC:
                                                    case EOS:
                                                    case END:
                                                    case EOF:
                                                        synch = true;
                                                        break;
                                                    default:
                                                        getNextToken();
                                                }
                                            }
                                        }
                                        if (e != null && !error) {
                                            if (i < dims) {
                                                Type intType = new IntegerType();
                                                if (intType.isCompatibleWith(e.getType())) {
                                                                        /*
									Controlling if the indices are out of bounds will make necessary evaluation
									of expressions at compile time.
									*/
                                                    ((IndexedVariable) v).setIndex(i, e);
                                                    i++;
                                                } else {
                                                    error = true;
                                                    printError(t.beginLine, t.beginColumn, "this expression is not of type integer");
                                                }
                                            } else {
                                                error = true;
                                                printError(t.beginLine, t.beginColumn, "too many indexes for this bracket");
                                            }
                                        }
                                        label_19:
                                        while (true) {
                                            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                                                case COMMA:
                                                    break;
                                                default:
                                                    jj_la1[50] = jj_gen;
                                                    break label_19;
                                            }
                                            t2 = jj_consume_token(COMMA);
                                            try {
                                                e = null;
                                                e = expression(scope);
                                                if (e == null)
                                                    error = true;
                                            } catch (ParseException exc) {
                                                error = true;
                                                boolean synch = false;
                                                printParseExc(exc);
                                                while (!synch) {
                                                    switch (getToken(1).kind) {
                                                        case COMMA:
                                                        case CL_BRAC:
                                                        case EOS:
                                                        case END:
                                                        case EOF:
                                                            synch = true;
                                                            break;
                                                        default:
                                                            getNextToken();
                                                    }
                                                }
                                            }
                                            if (e != null && !error) {
                                                if (i < dims) {
                                                    Type intType = new IntegerType();
                                                    if (intType.isCompatibleWith(e.getType())) {
                                                                                /*
										Controlling if the indices are out of bounds will make necessary evaluation
										of expressions at compile time.
										*/
                                                        ((IndexedVariable) v).setIndex(i, e);
                                                        i++;
                                                    } else {
                                                        error = true;
                                                        printError(t2.beginLine, t2.beginColumn, "this expression is not of type integer");
                                                    }
                                                } else {
                                                    error = true;
                                                    printError(t.beginLine, t.beginColumn, "too many indexes for this bracket");
                                                }
                                            }
                                        }
                                        jj_consume_token(CL_BRAC);
                                        if (!error && (i < dims)) {
                                            error = true;
                                            printError(t.beginLine, t.beginColumn, "not enough indexes for this bracket");
                                        }
                                    }
                                    jj_consume_token(ASSIGN);
                                    try {
                                        e = null;
                                        e = expression(scope);
                                        if (e == null)
                                            error = true;
                                    } catch (ParseException exc) {
                                        error = true;
                                        boolean synch = false;
                                        printParseExc(exc);
                                        while (!synch) {
                                            switch (getToken(1).kind) {
                                                case EOS:
                                                case END:
                                                case EOF:
                                                    synch = true;
                                                    break;
                                                default:
                                                    getNextToken();
                                            }
                                        }
                                    }
                                    if (!error) {
                                        if (v == null) {
                                            if (((Function) ste.getObject()).getReturnType().isCompatibleWith(e.getType())) {
                                                if (fname == null) {
                                                    error = true;
                                                    printError(idtok.beginLine, idtok.beginColumn, "return statement without a function");
                                                } else if (ste.getName().compareTo(fname) == 0) {
                                                    s = new AssignStatement(ste, e);
                                                    s.setLine(idtok.beginLine);
                                                    s.setColumn(idtok.beginColumn);
                                                } else {
                                                    error = true;
                                                    printError(idtok.beginLine, idtok.beginColumn, "return statement for function \"" + ste.getName() + "\", within function \"" + fname + "\"");
                                                }
                                            } else {
                                                error = true;
                                                printError(idtok.beginLine, idtok.beginColumn, "incompatible types : at assignment\nfound : " + e.getType() + "\nrequired : " + ((Function) ste.getObject()).getReturnType());
                                            }
                                        } else {
                                            if (v.getType() instanceof ArrayType) {
                                                error = true;
                                                printError(idtok.beginLine, idtok.beginColumn, "only one position of an array can be assigned at a time");
                                            }
                                            if (v.getType().isCompatibleWith(e.getType()))
                                                s = new AssignStatement(v, e);
                                            else {
                                                error = true;
                                                printError(idtok.beginLine, idtok.beginColumn, "incompatible types : at assignment\nfound : " + e.getType() + "\nrequired : " + v.getType());
                                            }
                                        }
                                    }
                                    break;
                                default:
                                    jj_la1[51] = jj_gen;
                                    jj_consume_token(-1);
                                    throw new ParseException();
                            }
                            break;
                        default:
                            jj_la1[52] = jj_gen;
                    }
                    if (s == null && !error) {
                        if (ste.getObject() instanceof Procedure) {
                            FunctionCall fcAux = new FunctionCall(ste);
                            if (fcAux.isCorrect())
                                s = new FunctionCallStatement(fcAux);
                            else {
                                error = true;
                                printError(idtok.beginLine, idtok.beginColumn, fcAux.toString() + " cannot be applied to " + fcAux.getFunctionString());
                            }
                        } else if (ste.getObject() instanceof Function) {
                            FunctionCall fcAux = new FunctionCall(ste);
                            if (!fcAux.isCorrect()) {
                                error = true;
                                printError(idtok.beginLine, idtok.beginColumn, fcAux.toString() + " cannot be applied to " + fcAux.getFunctionString());
                            }
                            error = true;
                            printError(idtok.beginLine, idtok.beginColumn, "\"" + t.image + "\" is a function, but its return value it is not used");
                        } else {
                            error = true;
                            printError(t.beginLine, t.beginColumn, "identifier \"" + t.image + "\" does not represent a procedure");
                        }
                    }
                    break;
                case BEGIN:
                    jj_consume_token(BEGIN);
                    s = new BlockStatement();
                    retst = false;
                    int line = 0, column = 0;
                    label_20:
                    while (true) {
                        switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                            case BEGIN:
                            case IF:
                            case WHILE:
                            case CASE:
                            case ID:
                                break;
                            default:
                                jj_la1[53] = jj_gen;
                                break label_20;
                        }
                        try {
                            aux = statement(scope, fname);
                            if (retst) {
                                retst = false;
                                error = true;
                                printError(line, column, "return statement is not placed at the last line of the function");
                            }
                            if (aux == null)
                                error = true;
                            else if (aux instanceof AssignStatement) {
                                SymbolTableEntry steaux = ((AssignStatement) aux).getFunctName();
                                if (steaux != null) {
                                    line = aux.getLine();
                                    column = aux.getColumn();
                                    retst = true;
                                }
                            }
                            ((BlockStatement) s).addStatement(aux);
                            jj_consume_token(EOS);
                        } catch (ParseException exc) {
                            boolean synch = false;
                            printParseExc(exc);
                            while (!synch) {
                                switch (getToken(1).kind) {
                                    case END:
                                    case EOF:
                                        synch = true;
                                        break;
                                    case EOS:
                                        synch = true;
                                        getNextToken();
                                        break;
                                    default:
                                        getNextToken();
                                }
                            }
                        }
                    }
                    jj_consume_token(END);
                    break;
                case IF:
                    t = jj_consume_token(IF);
                    try {
                        e = null;
                        e = expression(scope);
                        if (e == null)
                            error = true;
                    } catch (ParseException exc) {
                        error = true;
                        boolean synch = false;
                        printParseExc(exc);
                        while (!synch) {
                            switch (getToken(1).kind) {
                                case THEN:
                                case BEGIN:
                                case EOS:
                                case EOF:
                                    synch = true;
                                    break;
                                default:
                                    getNextToken();
                            }
                        }
                    }
                    if (e != null) {
                        if (!(e.getType() instanceof BooleanType)) {
                            error = true;
                            printError(t.next.beginLine, t.next.beginColumn, "incompatible types : at IF expression\nfound : " + e.getType() + "\nrequired : boolean");
                        }
                    }
                    try {
                        jj_consume_token(THEN);
                    } catch (ParseException exc) {
                        error = true;
                        boolean synch = false;
                        printParseExc(exc);
                        while (!synch) {
                            switch (getToken(1).kind) {
                                case THEN:
                                    synch = true;
                                    getNextToken();
                                    break;
                                case BEGIN:
                                case EOS:
                                case EOF:
                                    synch = true;
                                    break;
                                default:
                                    getNextToken();
                            }
                        }
                    }
                    aux = statement(scope, fname);
                    if (aux == null)
                        error = true;
                    else if (aux.hasReturnStatement() != null) {
                        error = true;
                        printError(aux.hasReturnStatement().getLine(), aux.hasReturnStatement().getColumn(), "return statement is not placed at the last line of the function");
                    }
                    s = new IfStatement(e, aux);
                    if (jj_2_1(2)) {
                        jj_consume_token(EOS);
                        jj_consume_token(ELSE);
                        aux = statement(scope, fname);
                        if (aux == null)
                            error = true;
                        else if (aux.hasReturnStatement() != null) {
                            error = true;
                            printError(aux.hasReturnStatement().getLine(), aux.hasReturnStatement().getColumn(), "return statement is not placed at the last line of the function");
                        }
                        ((IfStatement) s).setBlockElse(aux);
                    } else {
                    }
                    break;
                case CASE:
                    t = jj_consume_token(CASE);
                    try {
                        e = null;
                        e = expression(scope);
                        if (e == null)
                            error = true;
                    } catch (ParseException exc) {
                        error = true;
                        boolean synch = false;
                        printParseExc(exc);
                        while (!synch) {
                            switch (getToken(1).kind) {
                                case OF:
                                case BEGIN:
                                case EOS:
                                case EOF:
                                    synch = true;
                                    break;
                                default:
                                    getNextToken();
                            }
                        }
                    }
                    try {
                        jj_consume_token(OF);
                    } catch (ParseException exc) {
                        error = true;
                        boolean synch = false;
                        printParseExc(exc);
                        while (!synch) {
                            switch (getToken(1).kind) {
                                case OF:
                                    synch = true;
                                    getNextToken();
                                    break;
                                case PLUS:
                                case MINUS:
                                case UNS_NUM:
                                case UNS_INT:
                                case STLIT:
                                case ID:
                                case ELSE:
                                case END:
                                case EOF:
                                    synch = true;
                                    break;
                                default:
                                    getNextToken();
                            }
                        }
                    }
                    if (e != null) {
                        exprType = e.getType();
                        if ((e.getType() instanceof ArrayType) ||
                                //(e.getType() instanceof StringType) ||
                                (e.getType() instanceof RealType)) {
                            error = true;
                            printError(t.next.beginLine, t.next.beginColumn, "type " + e.getType() + " cannot be used in a case statement");
                        }
                    }
                    s = new CaseStatement(e);
                    switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                        case TRUE:
                        case FALSE:
                        case PLUS:
                        case MINUS:
                        case ID:
                        case UNS_INT:
                        case UNS_NUM:
                        case STLIT:
                            caseSequence((CaseStatement) s, exprType, scope, fname);
                            label_21:
                            while (true) {
                                switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                                    case TRUE:
                                    case FALSE:
                                    case PLUS:
                                    case MINUS:
                                    case ID:
                                    case UNS_INT:
                                    case UNS_NUM:
                                    case STLIT:
                                        break;
                                    default:
                                        jj_la1[54] = jj_gen;
                                        break label_21;
                                }
                                caseSequence((CaseStatement) s, exprType, scope, fname);
                            }
                            switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                                case ELSE:
                                    jj_consume_token(ELSE);
                                    aux = statement(scope, fname);
                                    if (aux == null)
                                        error = true;
                                    ((CaseStatement) s).addCaseBlock(null, aux);
                                    jj_consume_token(EOS);
                                    break;
                                default:
                                    jj_la1[55] = jj_gen;
                            }
                            break;
                        case ELSE:
                            jj_consume_token(ELSE);
                            aux = statement(scope, fname);
                            if (aux == null)
                                error = true;
                            ((CaseStatement) s).addCaseBlock(null, aux);
                            jj_consume_token(EOS);
                            break;
                        default:
                            jj_la1[56] = jj_gen;
                            jj_consume_token(-1);
                            throw new ParseException();
                    }
                    jj_consume_token(END);
                    break;
                case WHILE:
                    t = jj_consume_token(WHILE);
                    try {
                        e = null;
                        e = expression(scope);
                        if (e == null)
                            error = true;
                    } catch (ParseException exc) {
                        error = true;
                        boolean synch = false;
                        printParseExc(exc);
                        while (!synch) {
                            switch (getToken(1).kind) {
                                case DO:
                                case BEGIN:
                                case EOS:
                                case EOF:
                                    synch = true;
                                    break;
                                default:
                                    getNextToken();
                            }
                        }
                    }
                    if (e == null)
                        error = true;
                    else if (!(e.getType() instanceof BooleanType)) {
                        error = true;
                        printError(t.next.beginLine, t.next.beginColumn, "incompatible types : at WHILE expression\nfound : " + e.getType() + "\nrequired : boolean");
                    }
                    try {
                        jj_consume_token(DO);
                    } catch (ParseException exc) {
                        error = true;
                        boolean synch = false;
                        printParseExc(exc);
                        while (!synch) {
                            switch (getToken(1).kind) {
                                case DO:
                                    synch = true;
                                    getNextToken();
                                    break;
                                case BEGIN:
                                case EOS:
                                case EOF:
                                    synch = true;
                                    break;
                                default:
                                    getNextToken();
                            }
                        }
                    }
                    aux = statement(scope, fname);
                    if (aux == null)
                        error = true;
                    else if (aux.hasReturnStatement() != null) {
                        error = true;
                        printError(aux.hasReturnStatement().getLine(), aux.hasReturnStatement().getColumn(), "return statement is not placed at the last line of the function");
                    }
                    s = new WhileStatement(e, aux);
                    break;
                default:
                    jj_la1[57] = jj_gen;
                    jj_consume_token(-1);
                    throw new ParseException();
            }
        } catch (ParseException exc) {
            error = true;
            boolean synch = false;
            printParseExc(exc);
            while (!synch) {
                switch (getToken(1).kind) {
                    case END:
                    case EOS:
                    case EOF:
                        synch = true;
                        break;
                    default:
                        getNextToken();
                }
            }
        }
        if (error) {
            if (true) return null;
        } else {
            if (true) return s;
        }
        throw new Error("Missing return statement in function");
    }

    static final public void caseSequence(CaseStatement s, Type exprType, String scope, String fname) throws ParseException {
        boolean error = false;
        Vector v = new Vector();
        Constant c;
        Statement aux;
        IntWrapper line = new IntWrapper();
        IntWrapper column = new IntWrapper();
        try {
            c = constant(scope, line, column);
            v.add(c);
            v.add(line);
            v.add(column);
            label_22:
            while (true) {
                switch ((jj_ntk == -1) ? jj_ntk() : jj_ntk) {
                    case COMMA:
                        break;
                    default:
                        jj_la1[58] = jj_gen;
                        break label_22;
                }
                jj_consume_token(COMMA);
                line = new IntWrapper();
                column = new IntWrapper();
                c = constant(scope, line, column);
                v.add(c);
                v.add(line);
                v.add(column);
            }
            jj_consume_token(COLON);
            aux = statement(scope, fname);
            if (aux != null) {
                if (aux.hasReturnStatement() != null) {
                    printError(aux.hasReturnStatement().getLine(), aux.hasReturnStatement().getColumn(), "return statement is not placed at the last line of the function");
                } else {
                    for (int i = 0; i < v.size(); i += 3) {
                        c = (Constant) v.elementAt(i);
                        line = (IntWrapper) v.elementAt(i + 1);
                        column = (IntWrapper) v.elementAt(i + 2);
                        if (c != null && exprType != null) {
                            if (exprType.isCompatibleWith(c.getType())) {
                                if (s.isRepeated(c))
                                    printError(line.getValue(), column.getValue(), "case block for constant \"" + c + "\" is defined twice");
                                else
                                    s.addCaseBlock(c, aux);
                            } else {
                                printError(line.getValue(), column.getValue(), "incompatible types : at CASE constant\nfound : " + c.getType() + "\nrequired : " + exprType);
                            }
                        }
                    }
                }
            }
            jj_consume_token(EOS);
        } catch (ParseException exc) {
            error = true;
            boolean synch = false;
            printParseExc(exc);
            while (!synch) {
                switch (getToken(1).kind) {
                    case END:
                    case EOF:
                        synch = true;
                        break;
                    case EOS:
                        synch = true;
                        getNextToken();
                        break;
                    default:
                        getNextToken();
                }
            }
        }
    }

    static final private boolean jj_2_1(int xla) {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try {
            return !jj_3_1();
        } catch (LookaheadSuccess ls) {
            return true;
        } finally {
            jj_save(0, xla);
        }
    }

    static final private boolean jj_3_1() {
        if (jj_scan_token(EOS)) return true;
        return jj_scan_token(ELSE);
    }

    private static void jj_la1_0() {
        jj_la1_0 = new int[]{0x1000000, 0x2000000, 0x800000, 0x600000, 0x600000, 0x65000, 0x1000000, 0x2000000, 0x800000, 0x65000, 0x0, 0x0, 0x20000000, 0x0, 0x0, 0x0, 0x0, 0xc000000, 0xc000000, 0xc000000, 0xc000000, 0x0, 0x0, 0x0, 0x0, 0x20000000, 0x0, 0x0, 0x0, 0x0, 0x0, 0x10000000, 0x0, 0x20000000, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x20000000, 0x0, 0x20000000, 0x0, 0x0, 0xc000000, 0x20000000, 0x0, 0x20000000, 0x0, 0x0, 0x65000, 0xc000000, 0x10000, 0xc010000, 0x65000, 0x20000000,};
    }

    private static void jj_la1_1() {
        jj_la1_1 = new int[]{0x0, 0x0, 0x0, 0x0, 0x0, 0x10000000, 0x0, 0x0, 0x0, 0x10000000, 0x10000000, 0x10000000, 0x0, 0x10000000, 0x60, 0x60, 0x70000000, 0x0, 0xf0000060, 0x0, 0xe0000000, 0x60, 0x60, 0x60, 0x60, 0x0, 0x60, 0x60, 0x60, 0x60, 0x13e00000, 0x0, 0x8, 0x0, 0x1f8000, 0x1f8000, 0x60, 0x60, 0x1060, 0x1060, 0xf80, 0xf80, 0x0, 0x2, 0x0, 0xa, 0xa, 0xf0002008, 0x0, 0x2, 0x0, 0x400a, 0x400a, 0x10000000, 0xf0000060, 0x0, 0xf0000060, 0x10000000, 0x0,};
    }

    private static void jj_la1_2() {
        jj_la1_2 = new int[]{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0,};
    }

    static public void ReInit(java.io.InputStream stream) {
        ReInit(stream, null);
    }

    static public void ReInit(java.io.InputStream stream, String encoding) {
        try {
            jj_input_stream.ReInit(stream, encoding, 1, 1);
        } catch (java.io.UnsupportedEncodingException e) {
            throw new RuntimeException(e);
        }
        PascalSpimTokenManager.ReInit(jj_input_stream);
        token = new Token();
        jj_ntk = -1;
        jj_gen = 0;
        for (int i = 0; i < 59; i++) jj_la1[i] = -1;
        for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
    }

    static public void ReInit(java.io.Reader stream) {
        jj_input_stream.ReInit(stream, 1, 1);
        PascalSpimTokenManager.ReInit(jj_input_stream);
        token = new Token();
        jj_ntk = -1;
        jj_gen = 0;
        for (int i = 0; i < 59; i++) jj_la1[i] = -1;
        for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
    }

    static final private Token jj_consume_token(int kind) throws ParseException {
        Token oldToken;
        if ((oldToken = token).next != null) token = token.next;
        else token = token.next = PascalSpimTokenManager.getNextToken();
        jj_ntk = -1;
        if (token.kind == kind) {
            jj_gen++;
            if (++jj_gc > 100) {
                jj_gc = 0;
                for (int i = 0; i < jj_2_rtns.length; i++) {
                    JJCalls c = jj_2_rtns[i];
                    while (c != null) {
                        if (c.gen < jj_gen) c.first = null;
                        c = c.next;
                    }
                }
            }
            return token;
        }
        token = oldToken;
        jj_kind = kind;
        throw generateParseException();
    }

    static final private boolean jj_scan_token(int kind) {
        if (jj_scanpos == jj_lastpos) {
            jj_la--;
            if (jj_scanpos.next == null) {
                jj_lastpos = jj_scanpos = jj_scanpos.next = PascalSpimTokenManager.getNextToken();
            } else {
                jj_lastpos = jj_scanpos = jj_scanpos.next;
            }
        } else {
            jj_scanpos = jj_scanpos.next;
        }
        if (jj_rescan) {
            int i = 0;
            Token tok = token;
            while (tok != null && tok != jj_scanpos) {
                i++;
                tok = tok.next;
            }
            if (tok != null) jj_add_error_token(kind, i);
        }
        if (jj_scanpos.kind != kind) return true;
        if (jj_la == 0 && jj_scanpos == jj_lastpos) throw jj_ls;
        return false;
    }

    static final public Token getNextToken() {
        if (token.next != null) token = token.next;
        else token = token.next = PascalSpimTokenManager.getNextToken();
        jj_ntk = -1;
        jj_gen++;
        return token;
    }

    static final public Token getToken(int index) {
        Token t = lookingAhead ? jj_scanpos : token;
        for (int i = 0; i < index; i++) {
            if (t.next != null) t = t.next;
            else t = t.next = PascalSpimTokenManager.getNextToken();
        }
        return t;
    }

    static final private int jj_ntk() {
        if ((jj_nt = token.next) == null)
            return (jj_ntk = (token.next = PascalSpimTokenManager.getNextToken()).kind);
        else
            return (jj_ntk = jj_nt.kind);
    }

    static private void jj_add_error_token(int kind, int pos) {
        if (pos >= 100) return;
        if (pos == jj_endpos + 1) {
            jj_lasttokens[jj_endpos++] = kind;
        } else if (jj_endpos != 0) {
            jj_expentry = new int[jj_endpos];
            for (int i = 0; i < jj_endpos; i++) {
                jj_expentry[i] = jj_lasttokens[i];
            }
            boolean exists = false;
            for (java.util.Enumeration e = jj_expentries.elements(); e.hasMoreElements(); ) {
                int[] oldentry = (int[]) (e.nextElement());
                if (oldentry.length == jj_expentry.length) {
                    exists = true;
                    for (int i = 0; i < jj_expentry.length; i++) {
                        if (oldentry[i] != jj_expentry[i]) {
                            exists = false;
                            break;
                        }
                    }
                    if (exists) break;
                }
            }
            if (!exists) jj_expentries.addElement(jj_expentry);
            if (pos != 0) jj_lasttokens[(jj_endpos = pos) - 1] = kind;
        }
    }

    static public ParseException generateParseException() {
        jj_expentries.removeAllElements();
        boolean[] la1tokens = new boolean[65];
        for (int i = 0; i < 65; i++) {
            la1tokens[i] = false;
        }
        if (jj_kind >= 0) {
            la1tokens[jj_kind] = true;
            jj_kind = -1;
        }
        for (int i = 0; i < 59; i++) {
            if (jj_la1[i] == jj_gen) {
                for (int j = 0; j < 32; j++) {
                    if ((jj_la1_0[i] & (1 << j)) != 0) {
                        la1tokens[j] = true;
                    }
                    if ((jj_la1_1[i] & (1 << j)) != 0) {
                        la1tokens[32 + j] = true;
                    }
                    if ((jj_la1_2[i] & (1 << j)) != 0) {
                        la1tokens[64 + j] = true;
                    }
                }
            }
        }
        for (int i = 0; i < 65; i++) {
            if (la1tokens[i]) {
                jj_expentry = new int[1];
                jj_expentry[0] = i;
                jj_expentries.addElement(jj_expentry);
            }
        }
        jj_endpos = 0;
        jj_rescan_token();
        jj_add_error_token(0, 0);
        int[][] exptokseq = new int[jj_expentries.size()][];
        for (int i = 0; i < jj_expentries.size(); i++) {
            exptokseq[i] = (int[]) jj_expentries.elementAt(i);
        }
        return new ParseException(token, exptokseq, tokenImage);
    }

    static final public void enable_tracing() {
    }

    static final public void disable_tracing() {
    }

    static final private void jj_rescan_token() {
        jj_rescan = true;
        for (int i = 0; i < 1; i++) {
            try {
                JJCalls p = jj_2_rtns[i];
                do {
                    if (p.gen > jj_gen) {
                        jj_la = p.arg;
                        jj_lastpos = jj_scanpos = p.first;
                        switch (i) {
                            case 0:
                                jj_3_1();
                                break;
                        }
                    }
                    p = p.next;
                } while (p != null);
            } catch (LookaheadSuccess ls) {
            }
        }
        jj_rescan = false;
    }

    static final private void jj_save(int index, int xla) {
        JJCalls p = jj_2_rtns[index];
        while (p.gen > jj_gen) {
            if (p.next == null) {
                p = p.next = new JJCalls();
                break;
            }
            p = p.next;
        }
        p.gen = jj_gen + xla - jj_la;
        p.first = token;
        p.arg = xla;
    }

    public void ReInit(PascalSpimTokenManager tm) {
        token_source = tm;
        token = new Token();
        jj_ntk = -1;
        jj_gen = 0;
        for (int i = 0; i < 59; i++) jj_la1[i] = -1;
        for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
    }

    static private final class LookaheadSuccess extends java.lang.Error {
    }

    static final class JJCalls {
        int gen;
        Token first;
        int arg;
        JJCalls next;
    }

}
